### 是否符合测试案例

1.是否有这样的测试⽤例，代表了⼀个有效的不规则三⾓形？（注意，如1、2、3和2、5、10这样的测试⽤例并不能确保“是”的答案，因为具备这样边⻓的三⾓形不存在。）
2.是否有这样的测试⽤例，代表⼀个有效的等边三⾓形？
3.是否有这样的测试⽤例，代表⼀个有效的等腰三⾓形？（注意，如2、2、4的测试⽤例⽆效，因为这不是⼀个有效的三⾓形。）
4.是否⾄少有三个这样的测试⽤例，代表有效的等腰三⾓形，从⽽可以测试到两等边的所有三种可能情况（如3、3、4；3、4、3；4、3、3）？
5.是否有这样的测试⽤例，某边的⻓度等于0？
6.是否有这样的测试⽤例，某边的⻓度为负数？
7.是否有这样的测试⽤例，三个整数皆⼤于0，其中两个整数之和等于第三个？（也就是说，如果程序判断1、2、3表⽰⼀个不规则三⾓形，它可能就包含⼀个缺陷。）
8.是否⾄少有三个第7类的测试⽤例，列举了⼀边等于另外两边之和的全部可能情况（如1、2、3；1、3、2；3、1、2）？
9.是否有这样的测试⽤例，三个整数皆⼤于0，其中两个整数之和⼩于第三个整数（如1、2、4；12、15、30）？
10.是否⾄少有三个第9类的测试⽤例，列举了⼀边⼤于另外两边之和的全部可能情况（如1、2、4；1、4、2；4、1、2）？
11.是否有这样的测试⽤例，三边⻓度皆为0（0，0，0）？
12.是否⾄少有⼀个这样的测试⽤例，输⼊的边⻓为⾮整数值（如2.5、3.5、5.5）？
13.是否⾄少有⼀个这样的测试⽤例，输⼊的边⻓个数不对（如仅输⼊了两个⽽不是三个整数）？
14.对于每⼀个测试⽤例，除了定义输⼊值之外，是否定义了程序针对该输⼊值的预期输出值？

定义：“测试是为发现错误⽽执⾏程序的过程”。
软件做了其应该做的，未做其不应该做的。

经济学
⿊盒测试——数据驱动，⽩盒测试——逻辑驱动
穷举路径测试：
1.程序可能会因为缺少某些路径⽽存在问题。
2.穷举路径测试可能不会暴露数据敏感错误。

软件测试重要原则
1.测试⽤例中⼀个必需部分是对预期输出或结果的定义
a)对程序的输入数据的描述。
b)对程序在上述输入数据下的正确输出结果的精确描述。
2.程序员应当避免测试⾃⼰编写的程序
3.编写软件的组织不应当测试⾃⼰编写的软件
4.应当彻底检查每个测试的执⾏结果。
5.测试用例的编写不仅应当根据和有效预期的输出情况，⽽且也应当根据无效和未预料到的输入情况。
6.检查程序是否“未做其应该做的”仅是测试的⼀半，测试的另⼀半是检查程序是否“做了其不应该做的”。
7.应避免测试用例用后即弃，除非软件本身是⼀个⼀次性的软件
8.计划测试⼯作时不应默许假定不会发现错误。
9.程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比。
10.软件测试是⼀项极富创造性、极具智⼒挑战性的⼯作。

成功的测试用例能够发现未知的错误。

代码检查
优点：⼀旦发现错误，通常就能在代码中对其进⾏精确定位
代码小组：由四⼈组成

走查
评审

### 数据引用错误：
1. 是否有引⽤的变量未赋值或未初始化？    
2. 规定的界限之内  
3. 数组引⽤是否每个下标的值都是整数？  
4. 指针或引⽤变量时，内存单元是否分配（虚调用）？
5. 通过别名引用时，内存区域中的数据值是否具有正确的属性？
6. 变量值的类型或属性是否与编译器所预期的⼀致？
7. 内存分配的单元⼩于内存可寻址的单元⼤⼩时，是否存在直接或间接的寻址错误？
8. 当使⽤指针或引⽤变量时，被引⽤的内存的属性是否与编译器所预期的⼀致？
9. ⼀个数据结构在多个过程中被引用，那么每个过程或⼦程序对该结构的定义是否都相同？
10. 边界取值是否有“仅差⼀个”（off-by-one）的错误？
11. 是否所有的继承需求都在实现类中得到了满⾜？

#### 数据声明错误：
1. 是否所有的变量都进⾏了明确的声明？ 
2. 变量没有声明时，那么默认的属性能否被正确理解？
3. 变量初始化是否正确？
4. 是否每个变量都被赋予了正确的⻓度和数据类型？
5. 变量的初始化是否与其存储空间的类型⼀致？
6. 是否存在着相似名称的变量（如VOLT和VOLTS）？(会产生警告)

#### 运算错误：
1. 是否有混合模式的运算？eg: 将浮点变量与⼀个整型变量做加法运算
2. 是否有相同数据类型、不同字⻓变量间的运算？
3. 赋值语句的⽬标变量的数据类型是否⼩于右边表达式的数据类型或结果？
4. 是否存在表达式向上或向下溢出的情况?
5. 除数是否可能为0？
6. 基于⼆进制的，那么运算结果是否不精确？
7. 运算是否有使⽤不当的情况，尤其是除法？

#### ⽐较错误：
1. 是否有不同数据类型的变量之间的⽐较运算
2. 是否有混合模式的⽐较运算？应确保程序能正确理解转换规则。
3. ⽐较运算符是否正确？
4. 每个布尔表达式所叙述的内容是否都正确？
5. 布尔运算符的操作数是否是布尔类型的？
6. 是否有⽤⼆进制表⽰的⼩数或浮点数的⽐较运算？
7. 编译器计算布尔表达式的⽅式是否会对程序产⽣影响？

#### 控制流程错误：
1. 是否所有的循环最终都终⽌了？
2. 程序、模块或⼦程序是否最终都终⽌了？
3. 由于实际情况没有满⾜循环的⼊⼝条件，循环体是否有可能从未执⾏过？
4. 如果循环同时由迭代变量和⼀个布尔条件所控制（如⼀个搜索循环），如果循环越界（fall-through）了，后果会如何？
5. 是否存在“仅差⼀个”的错误，如迭代数量恰恰多⼀次或少⼀次？（从0开始
6. 是否每⼀个左括号都对应有⼀个右括号？
7. 是否存在不能穷尽的判断？

#### 接口错误：
1. 被调⽤模块接收到的形参数量是否等于调⽤模块发送的实参，顺序是否正确？
2. 实参的属性是否与相应形参的属性相匹配？
3. 实参的量纲是否与对应形参的量纲相匹配？
4. 该模块传递给其他模块的实参数量，是否等于其他模块期望的形参数量？
5. 此模块传递给彼模块的实参的属性，是否与彼模块相应形参的属性相匹配？
6. 此模块传递给彼模块的实参的量纲，是否与彼模块相应形参的量纲相匹配？
7. 如果调⽤了内置函数，实参的数量、属性、顺序是否正确？
8. 如果某个模块或类有多个⼊⼝点，是否引⽤了与当前⼊⼝点⽆关的形参？
9. 是否有⼦程序改变了某个原本仅为输⼊值的形参？
10. 如果存在全局变量，在所有引⽤它们的模块中，它们的定义和属性是否相同？
11. 常数是否以实参形式传递过？

#### 输入/输出错误：
1. 如果对⽂件明确声明过，其属性是否正确？
2. 打开⽂件的语句中各项属性的设置是否正确？
3. 格式规范是否与I/O语句中的信息相吻合？ 
4. 是否有⾜够的可⽤内存空间，来保留程序将读取的⽂件？
5. 是否所有的⽂件在使⽤之前都打开了？
6. 是否所有的⽂件在使⽤之后都关闭了？
7. 是否判断⽂件结束的条件，并正确处理？
8. 对I/O出错情况处理是否正确？
9. 任何打印或显⽰的⽂本信息中是否存在拼写或语法错误？
10. 程序是否正确处理了类似于“File Not Found”这样的错误？

#### 人工检测方法：
桌面检查、小组代码走查、同行评审、利用错误列表进行代码检查


**黑盒测试**：等价类划分、边界值分析、因果图分析、错误猜测
**白盒测试**：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、多重条件覆盖

判断覆盖、分支覆盖是较强的逻辑覆盖原则
判断语句满足语句覆盖，但还有三种额外情况：
1. 程序中不存在判断
2. 程序有多重入口
3. 在ON单元（ON-unit）⾥的语句。遍历每条分⽀路径并不一定能确保所有的ON单元都能执行到。
解决左右为难的局面，将一个判断的所有条件都执行一遍，将每个判断的所有可能都执行一次，每个入口点都至少调用一次。

黑盒测试：
1. 严格控制测试用例的增加
2. 它覆盖⼤部分其他可能的测试用例。

#### 等价类的指导原则：
|取值|等价类|
| ---- | ---- |
输入⼀个取值范围|确定一个有效等价类，两个无效等价类
输入取值个数|确定一个有效等价类，两个无效等价类
输入一个取值集合|确定一个有效等价类，一个无效等价类
输入“必须是”|确定一个有效等价类，一个无效等价类

#### 边界值分析通用指南：
1. 针对刚刚越界的情况设计无效输⼊测试用例
2. 针对最小数量、最大数量、比最小数量少一，比最大数量多一的情况设计测试用例。
3. 摘要数量：从未超过4条的
4. 输⼊或输是一个有序序列，注意第一个元素和最后一个元素

#### 因果图：
弱点：未对输入条件的组合进行分析，不能生成全部应该被确定的有效测试例
优点：高效的测试用例集合						难点：将因果图转化为判定表
（预期输入是因果图方法的固有部分）

#### 过程：
1. 将规格说明分解为可执⾏的⽚段
2. ¥Ç规格说明中的果ÓÅ。î谓“”，是指⼀i明¥的输·´件或输·´件的等价®。î谓“果”，是指⼀i输´件或Å统转换（输·对程N或Å统状态的延续影响）。
3. 分析规格说明的语义内容，并将其转换为连接因果关系的布尔图

其余所有的原因约束条件都是“要求”关系

#### 注意：
1. 路径敏感性：回溯经过节点为1的or点，不要同时将or点一个以上的输入输入设置为1。目的：避免由于原因之间的屏蔽而漏掉某些错误
2. 经过节点为0的and点的时候，无需罗列出其他输入可能为1的所有情况
3. 经过节点为0的and点的时候，仅有一种所有输入皆为0的情况需要啊输出

错误猜测：
数量为：“没有”“一个”

#### 测试策略：
包含输入输入条件组合，使用因果图分析法
在任何情况下都应该使用边界值分析方法
确定有效和无效等价类

#### 模块测试：
总体上面向白盒测试

所代表的条件不可能发生，因此应该将它们排除掉

#### 增量测试：
1、内容
- 模块测试⽤例的编写形式。
- 可能⽤到的测试⼯具类型。
- 模块编码与测试顺序。
- ⽣成测试⽤例的成本以及调试的成本。

同时或按次序进行测试
测试单元需要一个特殊的驱动模块，一个或多个桩模块

2、结论
- 非增量工作量更大
- 增量能较早发现不匹配接口、不正确假设相关的变成程序
- 增量更简单，更彻底
- 非增量，更多机会并行操作

自顶向下：至少一个该模块的从属模块事先经过测试
将测试数据放置在外部⽂件中，由桩模块B读取并返回给模块A。
考虑：
1．存在关键部分尽早添加，新算法容易发生错误
2．将I/O模块尽可能早地添加进来

优点：
- 可以使我们发现人为的错误和问题。
- 可将程序演⽰给最终⽤户看。
- 证明程序的整体设计是合理的。
- 起到精神上的⿎舞作⽤。

自底向上
定义：要成为合乎条件的 下⼀个模块，该模块所有的从属模块（它调⽤的模块）都已经事先经过了测试。

一个特殊的驱动模块：即包含着有效的测试输⼊、调⽤被测 
模块且将输出显⽰出来

执行测试：
范围：在测试执⾏之前对测试⽤例集进⾏审核或检查
使⽤⾃动化测试⼯具可以使测试过程中的枯燥劳动减⾄最⼩。

更高级别的测试
⼀个软件产品开发周期的模型的流程
1.要求转换为⼀系列书⾯的需求。
2.评估可⾏性
3.外部规格说明
4.系统设计
5.设计程序或程序集合的结构
6.准确的规格说明

审视上述⽂档的形式
需求规格说明定义了为什么要开发程序。
⽬标定义了程序要做什么，以及应做得怎样。
外部规格说明定义了程序对⽤户的准确表现。
与后续阶段相关的⽂档越来越详细地规定了程序是如何建⽴起来的

补充方法：
1.使软件开发过程更加精密
2.每个阶段结束时可以引⼊⼀个独⽴的验证过程
3.对不同的开发阶段采⽤不同的测试⽅法。

适用对象：软件产品

功能测试：黑盒
⽬的是为了暴露程序的错误以及发现程序与规格说明书中的不⼀致之处

系统测试
⽬标⽂档阐述了程序应该 做什么、做到什么程度，却没有说明程序功能如何表现。

### 系统测试
#### 能⼒测试	
1. 容量测试：是使程序经受⼤容量数据的检验
⽬的：为了证明程序不能处理⽬标⽂档中规定的数据容量
强度测试：很短的时间间隔内达到的数据或操作的数量峰值
			基于Web的应⽤程序是最常接受强度测试的软件之⼀。
可⽤性测试：
安全性测试：基于Web的应⽤程序常常⽐绝⼤多数程序所需的安全测试级别更⾼。
性能测试：在特定负载和配置环境下程序的响应时间和吞吐率
存储测试：程序使⽤的内存和辅存的容量，以及临时⽂件或溢出⽂件的⼤⼩
配置测试：
兼容性/转换测试：⾼度依赖于所使⽤的数据库系统
⽬的：证明兼容性⽬标未被满⾜，转换过程并未⽣效
安装测试：
可靠性测试：软件或系统有更为适中的平均故障间隔时间（MTBF）⽬标或合理的（以测试⽽⾔）功能错误⽬标
可恢复性测试：系统如何从程序错误、硬件失效和数据错误中恢复过来
⽬标：证明这些恢复机制不能够正确发挥作⽤。
服务/可维护性测试：服务辅助功能
⽂档测试：
过程测试：记录备份和恢复数据库系统的操作过程，这些资
源通常包括硬件和额外的软件许可证。

### 验收测试

#### 安装测试
1. ⽤户必须选择⼤量的选项。
2. 必须分配并加载⽂件和库。
3. 必须进⾏有效的硬件配置。
4. 软件可能要求⽹络联通，以便与其他软件连接。

#### 测试的计划与控制
1. ⽬标
2. 结束准则
3. 进度
4. 责任
5. 测试⽤例库及标准
6. ⼯具
7. 计算机时间
8. 硬件配置
9. 集成
10. 跟踪步骤
11. 调试步骤
12. 回归测试
*回归测试计划规定了测试⼈员、测试⽅法和测试时间，它也是必须的。*

错误预测：
1.预测出程序中错误的总数量。
2.预测这些错误中有多⼤⽐例可能通过测试⽽发现。
3.预测这些错误中有多少是由各个设计阶段产⽣的，以及在什么样的测试阶段能够发现这些问题

可用性测试：
1.考虑到最终⽤户的理解⼒、教育背景以及环境压⼒？   
2.输出是否有意义、没有侮辱性的词语，以及是否含糊不清？
3.错误诊断的提⽰的信息（error message）是直⽩易懂，还是需要计算机博⼠才可读懂？
4.⽤户界⾯上是否保持概念的⼀致、内部的连贯性、语法的⼀致性？是否符合约定的使⽤习惯、语义和句法规律、格式、样式以及缩写习惯？
5.需要⾼精确性和准确度的软件系统是否提供了⾜够有效的输⼊验证？
6.系统是不是包含了太多选项，或者包含的⼀些选项不会被使⽤？
7.对于来⾃⽤户的输⼊，系统是否能够及时做出反应？
8.操作是否很容易上⼿？
9.软件的设计是否有助于⽤户准确输⼊？
10.⽤户的操作可以轻松重复吗？
11.⽤户是否确定能够在众多的功能和菜单中来回切换⽽不发⽣意外？
12.软件的功能实现是否达到了设计规格要求？

修改场景：

测试人员可用性数量
E=100×（1-（1-L）^n）
E=找到错误的⽐例、n=测试⼈数、L=单个测试⼈员发现的可⽤性问题⽐例

Er图不能全部体现：业务流程、数据流程图

暴力测试法：
1.利⽤内存信息输出来调试。
2.根据⼀般的“在程序中插⼊打印语句”建议来调试。
3.使⽤⾃动化的调试⼯具进⾏调试。

归纳法测试：
是从线索（即错误的症状，可能是⼀个或多个测试⽤例的结果）出发，寻找线索之间的联系表格


随着软件规模扩⼤，修复⽼问题的同时引⼊新问题的可能性也更⼤。

共性：都忽略了思考的过程
使用场景：
（1）其他的⽅法都失败了；
（2）作为我们下⾯将会讨论的思考过程的补充，⽽不是替代⽅法。
顶层图：体现外部实体能收到的信息，并且能给实体的信息有哪些

演绎法调试
从⼀些普遍的理论或前提出发，使⽤排除和精炼的过程，达到⼀个结论（错误的位置）

如果都排除了，需要增加额外的测试用例；如果多于一个，主要假设

错误出现的地方：解释输入命令的部分和在输出列表上打印内存地址的部分

修改错误的技术：
1.存在⼀个缺陷的地⽅，很有可能还存在其他缺陷
2.应纠正错误本⾝，⽽不仅是其症状
3.正确纠正错误的可能性并⾮100%
4.随着程序规模的增加，正确修改错误的可能性反⽽降低
5.应意识改正错误会引⼊新错误的可能性
6.修改错误的过程也是临时回到设计阶段的过程
7.应修改源代码，⽽不是⽬标代码

错误分析：
1.错误出现在什么地⽅？
2.谁制造了这个错误？
3.哪些做得不正确？
4.如何避免该错误的出现？
5.为什么错误没有早些发现？
6.该如何更早地发现错误？

敏捷测试
提倡迭代式和增量式的开发模式，并强调测试在其中的重要作⽤。
是协同测试的⼀种形式，试需要客户尽早参与到开发周期中来并⼀直到其结束。

极限编程
通⽤任务的实现⽅法，都含有全功能的应⽤编程接⼝（API），消除或减少了构件⾃
定义类库的需要。

XP
短时间内开发⾼质量的程序。适合中⼩规模的软件开发
4个概念:
1.聆听客户和其他程序员的谈话。
2.与客户合作，开发应⽤程序的规格说明和测试⽤例。
3.结对编程。
4.反复测试代码库。
基于XP程序拥有的特征：
1.程序员与客户会晤，决定产品需求并建⽴使⽤场景。
2.在客户不在场的情况下，程序员间将需求分解为独⽴任务，并估计完成所需时间。
3.程序员向客户提交任务清单和时间估计，并要求客户产⽣⼀个功能优先级清单。
4.编程⼩组依据程序员具备的能⼒，将任务分配给结对的程序员。
5.每⼀对程序员依据应⽤程序的规格说明，对其编程任务⽣成单元测试⽤例。
6.每⼀对程序员完成其任务，旨在编写出通过单元测试的代码库。
7.每⼀对程序员在所有单元测试通过之前，不断修改和重测他们的代码。
8.所有的结对程序员每天都整合、集成他们的代码库。
9.编程⼩组发布应⽤程序的⼀个预览版本。
10.客户进⾏验收测试，要么确认该应⽤程序，要么提交⼀份报告指出存在的bug或不⾜。
11.程序员在验收测试成功的基础上发布⼀个产品版本。
12.程序员根据最新的经验更新时间估计。

三个共同点：依赖客户的参与、测试驱动以及紧凑的迭代开发周期。

极限测试：
验收测试：对缺陷进行优先级排序；可能通过所有的单元测试，但不能通过验收测试
	在设计测试时必须确定使用某个测试方法
应用程序是按照测试配件设计出来的

互联网应用测试
允许改变每一层的内部机制而不必担心其他层
业务层相关
事务处理。
⽤户⾝份鉴定。
数据确认。
程序⽇志。

测试的挑战：
⽤户群庞⼤且五花⼋门、业务环境、地点、安全性、测试环境
由于字符集的原因，本地化问题容易因截尾操作破坏数据。

测试财务软件所需工作量和成本最高
使这些系统的平均故障间隔时间（MTBF）最⼤，平均故障恢复时间（MTTR）最⼩。
需要⼀份规格说明⽂档来描述Web站点的预期功能和性能。
 
测试最终⽤⼾的环境（也被称为“浏览器兼容性测试”）

⽆论采⽤什么⽅法，应⽤系统中始终存在着⼀些可以测试的特性：
性能
数据有效性（最⼤挑战之⼀是复制应⽤系统的运⾏环境。）
	响应时间。
	数据完整性。
容错性和可恢复性。
事务

容错性和可恢复性测试：⽬标是最⼤化MTBF，最⼩化MTTR。
最⼤化MTBF取决于数据库系统的容错级别。
数据库的恢复具有同等的重要性。

移动设备的测试：
挑战主要来源于以下四个⽅⾯：设备多样性、运营商⽹络基础设施、⾃动化脚本编程与开发、可⽤性测试。
另⼀个挑战来⾃运营商⽹络。
理解运营商的基础设施和架构是良好设计测试计划的根基。

创建计划需要注意：括单机版的和基于Web的应⽤两种情况。
如果涉及信息传输，寻找那些可能发⽣在数据缓存中的bug，

⼿⼯测试脚本要尽量简要通⽤，不能太细致地描述在具体设备上的操作过程。很多测试⽤例很有可能会被废弃。所以应该尽量设计可以跨平台的通⽤测试脚本。

模拟器测试
通常却是最实⽤和最节约成本的
